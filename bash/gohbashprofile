## Profile Functions
augment_path_if_exists(){
	if [[ $# -lt 1 ]]; then
		echo "Requires argument of path to add."
		exit 1
	fi
	dirPath="$1"
	if [ -d "$dirPath" ]; then
		export PATH="$PATH:$dirPath";
	else
		echo "Unable to add directory to PATH: unable to find '$dirPath'"
	fi
}

export_if_exists(){
	if [[ $# -lt 2 ]]; then
		echo "Requires argument of variable name to export and path to check."
		exit 1
	fi
	variableName="$1"
	if [[ -z "$variableName" ]]; then
		echo "Empty variable name given. Exiting."
	fi
	path="$2"
	if [[ -z "$path" ]]; then
		echo "Empty variable name given. Exiting."
	fi
	if [ -e "$path" ]; then
		export "$variableName"="$path";
	else
		echo "Unable to export variable $variableName: unable to find '$path'"
	fi
}

# VARIABLES
export_if_exists GOPATH "${HOME}/Dropbox/go"
if [[ -n "$GOPATH" ]]; then
	export_if_exists GOBB "${GOPATH}/src/bitbucket.org/glynny"
	export_if_exists GOGH "${GOPATH}/src/github.com/GlynOwenHanmer"
fi
export_if_exists MONEY "$HOME/Dropbox/money"
if [[ -n "$MONEY" ]]; then
	export_if_exists MONEYDB "$MONEY/db"
fi
export_if_exists WIFICODES "$HOME/Dropbox/wifi_codes.txt"

[[ -n "$GOH_BASH_PROFILE" ]] && alias editGOH_BASH_PROFILE="subl -w $(dirname $GOH_BASH_PROFILE) && . $GOH_BASH_PROFILE"

# PATHS
augment_path_if_exists /usr/lib/postgresql/9.5/bin/
augment_path_if_exists /usr/local/go/bin
augment_path_if_exists "${HOME}/Dropbox/scripts"
augment_path_if_exists "${HOME}/Dropbox/scripts/music"

# ALIASES
# PERMANENT ALIASES
alias cant_touch='touch'
alias cdmamp='cd $MAMP'
alias cdname='echo ${PWD##*/}'
alias cp='cp -v'
alias datestring='date -u "+20%y%m%d_%H%M"'
alias editcron='env EDITOR=vim crontab -e'
alias externalip='curl -s https://4.ifcfg.me/'
alias egrep='egrep --color=auto'
alias fgrep='fgrep --color=auto'
alias golangDocs='godoc -http=:6060'
alias go-test-cover='go test -coverprofile=coverage.out && go tool cover -func=coverage.out && go tool cover -html=coverage.out'
alias gogland='/opt/*/bin/gogland.sh'
alias grep='grep --color=auto'
alias ipof='dig +short'
alias ls="ls -a"
alias lsusers='cut -d: -f1 /etc/passwd'
alias lslisteningports='netstat -lpn'
alias mv='mv -v'
SHRUG='¯\_(ツ)_/¯'

alias sshhosts='cat ~/.ssh/config | grep Host'
alias tree="find . -print | sed -e 's;[^/]*/;|____;g;s;____|; |;g'"

# AWS ALIASES
alias aws-describe-all-instances="aws ec2 describe-instances --query 'Reservations[*].Instances[*].{LaunchTime:LaunchTime,PublicIpAddress:PublicIpAddress,State:State.Name,InstanceId:InstanceId,Tags:Tags}'"

# AV ORRON GLYN ALIASES
alias squiggsmp4='ffmpeg -i ./squiggs-%06d.png  -c:v libx264 -vf format=yuv420p -r 30 squiggs.mp4'

disk-space(){
	baseDir="$1"
	if [[ -z "$baseDir" ]]; then
		echo "No base directory given, using root."
		baseDir="/"
	fi
	depth="$2"
	if [[ -z "$depth" ]]; then
		echo "No max depth given, using 1."
		depth=1
	fi
	sudo du -d"$depth" "$baseDir" | sort -g
}

# TEMPORARY ALIASES
[[ -n "$GOHBASHPROFILE" ]] && alias editGOHBASHPROFILE="subl -w $GOHBASHPROFILE && . $GOHBASHPROFILE"

# CONFIGS

# AWS CLI Completer
if [ -x /usr/local/bin/aws_completer ]; then
        complete -C '/usr/local/bin/aws_completer' aws;
fi;

if [ -x /usr/bin/aws_completer ]; then
        complete -C '/usr/bin/aws_completer' aws;
fi;

# FUNCTIONS
BBCproxy() {
	if [ -z ${http_proxy+x} ] || [ -z ${https_proxy+x} ]; then
		export http_proxy=http://www-cache.reith.bbc.co.uk:80;
		echo "setting http_proxy to $http_proxy";
		export https_proxy=http://www-cache.reith.bbc.co.uk:80;
		echo "setting https_proxy to $https_proxy";
	else 
		echo "http_proxy is already set to '$http_proxy'";
		echo "https_proxy is already set to '$https_proxy'";
		echo "Unset these proxies to change them using the BBCproxy function."
	fi
}

cdu() {
	echo "cd .. $1 times"
	COUNTER=0

	if ! [[ "$1" =~ ^[0-9]+$ ]]; then
		return "Argument should be an integer."
	fi

	while [[ $COUNTER -lt $1 ]] && [[ "$PWD" != "/" ]]; do
			pwd
			cd ..
			(( COUNTER++ ))
	done
	pwd
}

cdl() {
        echo "cd $1"
	echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
        cd $1
        ls
}

cdmus() {
	COMPUTER_NAME="$(scutil --get ComputerName)"
	checkName="Glyn’s iMac"

	if [[ "$COMPUTER_NAME" != "$checkName" ]]; then
		echo "You're on $COMPUTER_NAME, the wrong computer."
	else
		cd $MUSIC
	fi
}

echoArguments() {
	echo "\$# - $#"
	echo "\$* - $*"
	echo "\$@ - $@"
	echo "for var in \"\$@; do echo \"\$var\""
	for var in "$@"; do
		echo "$var"
	done
	echo "for var in \"\$*; do echo \"\$*var\""
	for var in "$*"; do
		echo "$var"
	done
}

externalIP() {
	wget http://ipinfo.io/ip -qO -
}

getproxy() {
	printf "=============SYSTEM:=============\n"
	system_profiler SPNetworkDataType | grep -i "proxy" | sed "s/^[ \t]*//"
	printf "=============SHELL:==============\n"
	echo "http_proxy:  $http_proxy"
	echo "https_proxy: $https_proxy"
}

install-and-log(){
	aptGetInstalledList=~/Dropbox/bash/package-installs/apt-get
	if [[ ! -f "$aptGetInstalledList" ]]; then
		echo "Unable to find log file at $aptGetInstalledList."
		echo "Will not be able to log install."
		echo "Exiting."
		return 1
	fi
	sudo apt-get install $1 && echo $1 >> "$aptGetInstalledList"
	if [[ $? -ne 0 ]]; then
		return $?
	fi
	echo "====LOGGED PACKAGES===="
	cat "$aptGetInstalledList"
}

historyplain() {
	tput bold
	history $@ | cut -c 8-
	tput sgr0
}

mkcd() {
	if [ -d "$1" ]; then
		echo "$1 is already a directory"
		echo "Would you like to go to it? (yes/no)"
		read answer
		if [ "$answer" == 'yes' ] || [ "$answer" == 'y' ]; then
			cd "$1"
		fi
	else 
		echo "Making directory $1..."
		mkdir -p "$1"
		echo "Entering directory $1..."
		cd "$1"
	fi
}

moneyjohnandemily() {
	cd $GOGH/GOHMoneyJAndE/
	go build
	exitStatus="$?"
	if [[ $exitStatus -ne 0 ]]; then
		echo "Unable build project"
		return $exitStatus
	fi
	./GOHMoneyJAndE
	exitStatus="$?"
	if [[ $exitStatus -ne 0 ]]; then
		echo "Error running GOHMoneyJAndE"
		return $exitStatus
	fi
}

moneybackups() {
	~/Dropbox/money/db/scripts/create-backups.sh
	exitStatus="$?"
	if [[ $exitStatus -ne 0 ]]; then
		echo "Unable to create-backups.sh. create-backups.sh error: $exitStatus"
		return $exitStatus
	fi
}

moneyjson() {
	cd $GOBB/GOHMoneyQuick/ && go build && ./GOHMoneyQuick
	exitStatus="$?"
	if [[ $exitStatus -ne 0 ]]; then
		echo "Unable to build money app and generate new json"
		return $exitStatus
	fi
}

moneygraph() {
	cp $HOME/Dropbox/go/src/bitbucket.org/glynny/GOHMoneyQuick/out/money.json $MONEY/moneygraph/src/data/money.json
	cd $HOME/Dropbox/money/moneygraph/src && python -m SimpleHTTPServer 8000
}

mp3DownloadsToMusic() {
	if [ -f $DOWNLOADS/*.mp3 ]; then
		echo "MP3S WOOOOH"
		for mp3File in $DOWNLOADS/*.mp3; do
			mv "$mp3File" "$MUSIC"
			echo "Moving "$mp3File""
		done
		echo "Files moved to $MUSIC"
	else
		echo "No .mp3 files to move from $DOWNLOADS directory"
	fi
}

rerun-latex() {
	if [[ $# -lt 1 ]]; then
		echo "No files given to monitor for changes."
	fi
	xelatexCommand=""
	chromeCommand=""
	joiner=' && '
	for texFile in "$@"; do
		xelatexCommand="${xelatexCommand}xelatex $texFile$joiner"
		pdf="${texFile%tex}pdf"
		chromeCommand="${chromeCommand}google-chrome $pdf$joiner"
	done
	chromeCommand=${chromeCommand%$joiner}
	echo "$xelatexCommand$chromeCommand"
	rerun --pattern '**/*.tex' "$xelatexCommand$chromeCommand"
}

ssh-disk-capacity(){
	echo "ONLY DISKS BEGINNING WITH /dev"
	for server in "$@"; do
	echo "$server";
	ssh "$server" 'df -h' | grep --color=none -E '^/dev';
	done
}

stats(){
	echo "OS: ${OS}"
	echo "Shell: ${SHELL}"
}

toucho() {
	if [ -f "$1" ]; then
		echo "$1 already exists."
		read answer
		echo "Would you like to open it? (yes/no)"
		if [[ "$answer" =~ ^(yes|ye|y)$ ]]; then 
			open "$1"
		else
		    echo "$answer is not in the list"
		fi
	else
		touch "$1"
		open "$1"
	fi
}

unsetProxies() {
	unset http_proxy
	unset https_proxy
}

wifiedit(){
	if [[ ! -f "$WIFICODES" ]]; then
		echo "Cannot find wifi codes file at $WIFICODES"
		exit 1
	fi
	vim $WIFICODES
}

wifi() {
	name="$1"
	if [[ -z "$name" ]]; then
		cat $WIFICODES
		exit
	fi
	grep -i $name $WIFICODES 
}

# I move across various *nix type OSes. I have found that it’s easiest to keep my login stuff (aliases & environment variables) in separate files as in .aliases-{OS}. E.g.:

# $HOME/.aliases-darwin
# $HOME/.aliases-linux
# All I have to do then in .bashrc, or .profile, whatever is do this:

OS=$( uname | tr '[:upper:]' '[:lower:]')
# . $HOME/.aliases-${OS}
# . $HOME/.environment_variables-${OS}
# and/or

# for SCRIPT in $( ls -1 $HOME/scripts/login/*-${OS} )
# do
#   . ${SCRIPT}
# done

bu() { cp $@ $@.backup-`date +%y%m%d`; echo "`date +%Y-%m-%d` backed up $PWD/$@" >> ${HOME}/.backups.log; }

OS=$( uname | tr '[:upper:]' '[:lower:]')
osSpecificProfile=$(dirname $GOH_BASH_PROFILE)/$OS
if [[ -f $osSpecificProfile ]]; then
	. $osSpecificProfile
else
	echo "No OS specific profile found at $osSpecificProfile"
fi