# VARIABLES
MONEY="$HOME/Dropbox/money"
MONEYDB="$HOME/Dropbox/money/db"
MUSICDATE="$(date "+20%y-%m_%B")"
MUSIC="$(date "+$HOME/Music/20%y-%m_%B")"
SERVICES=${HOME}/"Library/Services"
[[ -n "$GOH_BASH_PROFILE" ]] && alias editGOH_BASH_PROFILE="subl -w $GOH_BASH_PROFILE && . $GOH_BASH_PROFILE"

source /etc/bash_completion.d/git
operatingSystem="$(uname)"
if [[ $operatingSystem = 'Linux' ]]; then
	export PS1="\[\033[0;37m\][\!]\[\033[223m\][\w]\[\033[0m\]\[\033[1;36m\]\u\[\033[32m\]\$(__git_ps1 \"-(%s)\")$ \[\033[0m\]"
elif [[ $operatingSystem = 'Darwin' ]]; then
	export PS1="\[\033[0;37m\][\!]\[\033[223m\][\w]\[\033[0m\]\[\033[1;36m\]\u-\[\033[32m\]$ \[\033[0m\]"
fi

## Profile Functions
export_path_if_exists(){
	if [[ $# -lt 1 ]]; then
		echo "Requires argument of path to add."
		exit 1
	fi
	dirPath="$1"
	if [ -d "$dirPath" ]; then
		export PATH="$PATH:$dirPath";
	else
		echo "Unable to add directory to PATH: unable to find '$dirPath'"
	fi
}

export_if_exists(){
	if [[ $# -lt 2 ]]; then
		echo "Requires argument of variable name to export and path to check."
		exit 1
	fi
	variableName="$1"
	if [[ -z "$variableName" ]]; then
		echo "Empty variable name given. Exiting."
	fi
	path="$2"
	if [[ -z "$path" ]]; then
		echo "Empty variable name given. Exiting."
	fi
	if [ -e "$path" ]; then
		export "$variableName"="$path";
	else
		echo "Unable to export variable $variableName: unable to find '$path'"
	fi
}

export_path_if_exists /usr/lib/postgresql/9.5/bin/
export_path_if_exists "${HOME}/Dropbox/scripts"

### macOS PATHS
export_path_if_exists "/Library/TeX/Distributions/.DefaultTeX/Contents/Programs/texbin"
export_path_if_exists "/Applications/Postgres.app/Contents/Versions/latest/bin"
export_path_if_exists "/Applications/Sublime Text.app/Contents/SharedSupport/bin"
export_path_if_exists "/Applications/Sublime Text 2.app/Contents/SharedSupport/bin"

export_if_exists GOPATH "${HOME}/Dropbox/go"
export_if_exists GOGLYN "${GOPATH}/src/bitbucket.org/glynny"

# ALIASES
# PERMANENT ALIASES
alias cant_touch='touch'
alias cdmamp='cd $MAMP'
alias cdname='echo ${PWD##*/}'
alias cp='cp -v'
alias dateSorted='date +%Y%m%d_%H%M'
alias editcron='env EDITOR=nano crontab -e'
alias externalip='curl -s https://4.ifcfg.me/'
alias golangDocs='godoc -http=:6060'
alias grep='grep --color=auto'
alias fgrep='fgrep --color=auto'
alias egrep='egrep --color=auto'
alias ipof='dig +short'
alias ls="ls -a"
alias lsusers='cut -d: -f1 /etc/passwd'
alias lslisteningports='netstat -lpn'
alias mv='mv -v'
alias tree="find . -print | sed -e 's;[^/]*/;|____;g;s;____|; |;g'"
alias shrug='echo "¯\_(ツ)_/¯" && echo "¯\_(ツ)_/¯" | xsel -ib && echo "Copied to clipboard."'
alias sshhosts='cat ~/.ssh/config | grep Host'

# AWS ALIASES
alias aws-describe-all-instances="aws ec2 describe-instances --query 'Reservations[*].Instances[*].{LaunchTime:LaunchTime,PublicIpAddress:PublicIpAddress,State:State.Name,InstanceId:InstanceId,Tags:Tags}'"

# AV ORRON GLYN ALIASES
alias squiggsmp4='ffmpeg -i ./squiggs-%06d.png  -c:v libx264 -vf format=yuv420p -r 30 squiggs.mp4';

# RHQ PROFILE
export_if_exists RHQ "${HOME}/java_local/projects/riderhq"
alias rhq-disk-capacity='ssh-disk-capacity aws1 bm2 aws2 aws3 s5'

export_path_if_exists "${HOME}/java_local/projects/riderhq/deploy"
export_path_if_exists "${HOME}/java_local/projects/riderhq/scripts"
export_path_if_exists "${HOME}/Dropbox/riderhq/scripts"

disk-space(){
	baseDir="$1"
	if [[ -z "$baseDir" ]]; then
		echo "No base directory given, using root."
		baseDir="/"
	fi
	depth="$2"
	if [[ -z "$depth" ]]; then
		echo "No max depth given, using 1."
		depth=1
	fi
	sudo du -d"$depth" "$baseDir" | sort -g
}

fetchPayLog(){
	set -e
	logDir="/var/riderhq/googlecheckout/notifications"
	ssh pay -t "ls -ltr $logDir | tail -n 10"
	echo "Which pay log would you like to fetch?"
	read logName
	echo "$logName"
	logDest="${HOME}/$logName"
	scp "pay:$logDir/$logName" "$logDest"
	if [[ ! -f "$logDest" ]]; then
		echo "Log fetch failed..."
		exit 1
	fi
	echo "Log located at ${HOME}/$logName"
	echo "Open in sublime? [y/n]"
	read openInSublime
	if [[ "$openInSublime" != 'y' ]]; then
		exit
	fi
	subl "$logName"
}
# TEMPORARY ALIASES
[[ -n "$GOHBASHPROFILE" ]] && alias editGOHBASHPROFILE="subl -w $GOHBASHPROFILE && . $GOHBASHPROFILE"

# CONFIGS

# AWS CLI Completer
if [ -x /usr/local/bin/aws_completer ]; then
        complete -C '/usr/local/bin/aws_completer' aws;
fi;

if [ -x /usr/bin/aws_completer ]; then
        complete -C '/usr/bin/aws_completer' aws;
fi;

# FUNCTIONS
BBCproxy() {
	if [ -z ${http_proxy+x} ] || [ -z ${https_proxy+x} ]; then
		export http_proxy=http://www-cache.reith.bbc.co.uk:80;
		echo "setting http_proxy to $http_proxy";
		export https_proxy=http://www-cache.reith.bbc.co.uk:80;
		echo "setting https_proxy to $https_proxy";
	else 
		echo "http_proxy is already set to '$http_proxy'";
		echo "https_proxy is already set to '$https_proxy'";
		echo "Unset these proxies to change them using the BBCproxy function."
	fi
}

cdu() {
	echo "cd .. $1 times"
	COUNTER=0

	if ! [[ "$1" =~ ^[0-9]+$ ]]; then
		return "Argument should be an integer."
	fi

	while [[ $COUNTER -lt $1 ]] && [[ "$PWD" != "/" ]]; do
			pwd
			cd ..
			(( COUNTER++ ))
	done
	pwd
}

cdl() {
        echo "cd $1"
	echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
        cd $1
        ls
}

cdmus() {
	COMPUTER_NAME="$(scutil --get ComputerName)"
	checkName="Glyn’s iMac"

	if [[ "$COMPUTER_NAME" != "$checkName" ]]; then
		echo "You're on $COMPUTER_NAME, the wrong computer."
	else
		cd $MUSIC
	fi
}

echoArguments() {
	echo "\$# - $#"
	echo "\$* - $*"
	echo "\$@ - $@"
	echo "for var in \"\$@; do echo \"\$var\""
	for var in "$@"; do
		echo "$var"
	done
	echo "for var in \"\$*; do echo \"\$*var\""
	for var in "$*"; do
		echo "$var"
	done
}

externalIP() {
	wget http://ipinfo.io/ip -qO -
}

getproxy() {
	printf "=============SYSTEM:=============\n"
	system_profiler SPNetworkDataType | grep -i "proxy" | sed "s/^[ \t]*//"
	printf "=============SHELL:==============\n"
	echo "http_proxy:  $http_proxy"
	echo "https_proxy: $https_proxy"
}

install-and-log(){
	aptGetInstalledList=~/Dropbox/bash/package-installs/apt-get
	if [[ ! -f "$aptGetInstalledList" ]]; then
		echo "Unable to find log file at $aptGetInstalledList."
		echo "Will not be able to log install."
		echo "Exiting."
		return 1
	fi
	sudo apt-get install $1 && echo $1 >> "$aptGetInstalledList"
	if [[ $? -ne 0 ]]; then
		return $?
	fi
	echo "====LOGGED PACKAGES===="
	cat "$aptGetInstalledList"
}

historyplain() {
	tput bold
	history $@ | cut -c 8-
	tput sgr0
}

mkcd() {
	if [ -d "$1" ]; then
		echo "$1 is already a directory"
		echo "Would you like to go to it? (yes/no)"
		read answer
		if [ "$answer" == 'yes' ] || [ "$answer" == 'y' ]; then
			cd "$1"
		fi
	else 
		echo "Making directory $1..."
		mkdir -p "$1"
		echo "Entering directory $1..."
		cd "$1"
	fi
}

money() {
	subl -w ${HOME}/Dropbox/money/paypaltotal && ${HOME}/Dropbox/money/paypaltotal
}

mp3DownloadsToMusic() {
	if [ -f $DOWNLOADS/*.mp3 ]; then
		echo "MP3S WOOOOH"
		for mp3File in $DOWNLOADS/*.mp3; do
			mv "$mp3File" "$MUSIC"
			echo "Moving "$mp3File""
		done
		echo "Files moved to $MUSIC"
	else
		echo "No .mp3 files to move from $DOWNLOADS directory"
	fi
}

ssh-disk-capacity(){
	echo "ONLY DISKS BEGINNING WITH /dev"
	for server in "$@"; do
	echo "$server";
	ssh "$server" 'df -h' | grep --color=none -E '^/dev';
	done
}

stats(){
	echo "OS: ${OS}"
	echo "Shell: ${SHELL}"
}

toucho() {
	if [ -f "$1" ]; then
		echo "$1 already exists."
		read answer
		echo "Would you like to open it? (yes/no)"
		if [[ "$answer" =~ ^(yes|ye|y)$ ]]; then 
			open "$1"
		else
		    echo "$answer is not in the list"
		fi
	else
		touch "$1"
		open "$1"
	fi
}

unsetProxies() {
	unset http_proxy
	unset https_proxy
}

wifi() {
	name="$1"
	wifiCodes=~/Dropbox/wifi_codes.txt 
	if [[ -z "$name" ]]; then
		cat $wifiCodes
		exit
	fi
	grep -i $name $wifiCodes 
}

# I move across various *nix type OSes. I have found that it’s easiest to keep my login stuff (aliases & environment variables) in separate files as in .aliases-{OS}. E.g.:

# $HOME/.aliases-darwin
# $HOME/.aliases-linux
# All I have to do then in .bashrc, or .profile, whatever is do this:

OS=$( uname | tr '[:upper:]' '[:lower:]')
# . $HOME/.aliases-${OS}
# . $HOME/.environment_variables-${OS}
# and/or

# for SCRIPT in $( ls -1 $HOME/scripts/login/*-${OS} )
# do
#   . ${SCRIPT}
# done

bu() { cp $@ $@.backup-`date +%y%m%d`; echo "`date +%Y-%m-%d` backed up $PWD/$@" >> ${HOME}/.backups.log; }