HISTSIZE=1000

## Profile Functions
augment-path-if-exists(){
	if [[ $# -lt 1 ]]; then
		echo "Requires argument of path to add."
		exit 1
	fi
	for dirPath in "$@"; do
		# dirPath="$1"
		if [ -d "$dirPath" ]; then
			export PATH="$PATH:$dirPath";
		else
			echo "Unable to add directory to PATH: unable to find '$dirPath'"
		fi
	done
}

export-if-exists(){
	if [[ $# -lt 2 ]]; then
		echo "Requires argument of variable name to export and path to check."
		exit 1
	fi
	variableName="$1"
	if [[ -z "$variableName" ]]; then
		echo "Empty variable name given. Exiting."
	fi
	path="$2"
	if [[ -z "$path" ]]; then
		echo "Empty variable name given. Exiting."
	fi
	if [ -e "$path" ]; then
		export "$variableName"="$path";
	else
		echo "Unable to export variable $variableName: unable to find '$path'"
	fi
}

source-if-exists(){
	if [[ $# -ne 1 ]]; then
		echo "Requires 1 argument of file to source."
		return 1
	fi
	path="$1"
	if [[ -z "$path" ]]; then
		echo "No path provided"
		return 2
	fi
	if [[ ! -f "$path" ]]; then
		eccho "Cannot source file at $path: Not a file."
		return 3
	fi
	. "$path"
}

# VARIABLES

[[ -n "$GOHBASHPROFILE" ]] && alias editGOHBASHPROFILE="subl -w $(dirname $GOHBASHPROFILE) && . $GOHBASHPROFILE"

export SHRUG='¯\_(ツ)_/¯'

# ALIASES
# PERMANENT ALIASES
alias cdname='echo ${PWD##*/}'
alias cp='cp -v'
alias datestring='date -u "+20%y%m%d_%H%M"'
alias editcron='env EDITOR=vim crontab -e'
alias externalip='curl -s https://4.ifcfg.me/'
alias egrep='egrep --color=auto'
alias fgrep='fgrep --color=auto'
alias golangDocs='godoc -http=:6060'
alias gometalintermega="find . -type d ! -path './vendor*' ! -path './.wercker*' ! -path './.git*' ! -path './.idea*' ! -path './bin*' ! -path . -print0 | xargs -0 -I {} gometalinter {}/..."
alias grep='grep --color=auto'
alias ipof='dig +short'
alias ls="ls -a"
alias lsusers='cut -d: -f1 /etc/passwd'
alias lslisteningports='netstat -lpn'
alias mv='mv -v'
alias shrug="echo '$SHRUG' && echo '$SHRUG' | copy && echo \"Copied to clipboard.\""
alias sshhosts='cat ~/.ssh/config | grep Host'
alias tree="find . -print | sed -e 's;[^/]*/;|____;g;s;____|; |;g'"

# AWS ALIASES
alias aws-describe-all-instances="aws ec2 describe-instances --query 'Reservations[*].Instances[*].{LaunchTime:LaunchTime,PublicIpAddress:PublicIpAddress,State:State.Name,InstanceId:InstanceId,Tags:Tags}'"

# AV ORRON GLYN ALIASES
alias squiggsmp4='ffmpeg -i ./squiggs-%06d.png  -c:v libx264 -vf format=yuv420p -r 30 squiggs.mp4'

disk-space(){
	baseDir="$1"
	if [[ -z "$baseDir" ]]; then
		echo "No base directory given, using root."
		baseDir="/"
	fi
	depth="$2"
	if [[ -z "$depth" ]]; then
		echo "No max depth given, using 1."
		depth=1
	fi
	sudo du -d"$depth" "$baseDir" | sort -g
}

# AWS CLI Completer
if [ -x /usr/local/bin/aws_completer ]; then
        complete -C '/usr/local/bin/aws_completer' aws;
fi;

if [ -x /usr/bin/aws_completer ]; then
        complete -C '/usr/bin/aws_completer' aws;
fi;

# FUNCTIONS
BBCproxy() {
	if [ -z ${http_proxy+x} ] || [ -z ${https_proxy+x} ]; then
		export http_proxy=http://www-cache.reith.bbc.co.uk:80;
		echo "setting http_proxy to $http_proxy";
		export https_proxy=http://www-cache.reith.bbc.co.uk:80;
		echo "setting https_proxy to $https_proxy";
	else 
		echo "http_proxy is already set to '$http_proxy'";
		echo "https_proxy is already set to '$https_proxy'";
		echo "Unset these proxies to change them using the BBCproxy function."
	fi
}

bu() { cp $@ $@.backup-`date +%y%m%d`; echo "`date +%Y-%m-%d` backed up $PWD/$@" >> ${HOME}/.backups.log; }

cdu() {
	echo "cd .. $1 times"
	COUNTER=0

	if ! [[ "$1" =~ ^[0-9]+$ ]]; then
		return "Argument should be an integer."
	fi

	while [[ $COUNTER -lt $1 ]] && [[ "$PWD" != "/" ]]; do
			pwd
			cd ..
			(( COUNTER++ ))
	done
	pwd
}

cdl() {
        echo "cd $1"
	echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
        cd $1
        ls
}

echoArguments() {
	echo "\$# - $#"
	echo "\$* - $*"
	echo "\$@ - $@"
	echo "for var in \"\$@; do echo \"\$var\""
	for var in "$@"; do
		echo "$var"
	done
	echo "for var in \"\$*; do echo \"\$*var\""
	for var in "$*"; do
		echo "$var"
	done
}

externalIP() {
	wget http://ipinfo.io/ip -qO -
}

exit-if-error() {
	exitStatus="$1"
	message="$2"
	if [[ $exitStatus -ne 0 ]]; then
		printf "Exit status: $exitStatus. $2"
		exit $exitStatus
	fi
}

findflacs() {
	if [[ -z "$1" ]]; then
		echo "No find location given."
		return
	fi
	echo $2
	if [[ "$2" = 'avprobe' ]] || [[ "$2" = '--avprobe' ]] ; then
		find "$1" -iname '*.flac' -exec avprobe {} \;
	else
		find "$1" -iname '*.flac'
	fi
	
}

fswatchsimple() {
	echo "Watching: $1"
	echo "Command: ${@:2}"
	# fswatch -0 "$1" | xargs -0 grep -v 4913
	fswatch -0 "$1" | xargs -0 -n 1 -I "{}" "${@:2}"
	# something like this will work but I'm not sure what. fswatch "$1" | grep -Z -v 4913 | xargs -0 -n 1 -I "{}" "${@:2}"
}

git-checkout-pullrequest() {
	pr="$1"
	if [[ -z "$pr" ]]; then
		echo "No pull request given."
		return
	fi
	branchName="pullrequest-$(datestring)"
	git fetch origin "pull/$pr/head:$branchName"
	git checkout "$branchName"
}

getproxy() {
	printf "=============SYSTEM:=============\n"
	system_profiler SPNetworkDataType | grep -i "proxy" | sed "s/^[ \t]*//"
	printf "=============SHELL:==============\n"
	echo "http_proxy:  $http_proxy"
	echo "https_proxy: $https_proxy"
}

historyplain() {
	tput bold
	history $@ | cut -c 8-
	tput sgr0
}

install-and-log(){
	aptGetInstalledList=~/Dropbox/bash/package-installs/apt-get
	if [[ ! -f "$aptGetInstalledList" ]]; then
		echo "Unable to find log file at $aptGetInstalledList."
		echo "Will not be able to log install."
		echo "Exiting."
		return 1
	fi
	sudo apt-get install $1 && echo $1 >> "$aptGetInstalledList"
	if [[ $? -ne 0 ]]; then
		return $?
	fi
	echo "====LOGGED PACKAGES===="
	cat "$aptGetInstalledList"
}

kubectl-getall(){
	for entity in \
	node \
	pod \
	deployment \
	replicationcontroller "nodes -o jsonpath='{.items[*].status.addresses}'" \
	replicaset \
	service \
	; do
		printf "\n"
		echo $entity | tr '[:lower:]' '[:upper:]'
		kubectl get $entity
	done
	printf "\n"
	echo "Port Forwarding" | tr '[:lower:]' '[:upper:]'
	ps -ef | grep "kubectl port-forward"
}

kubectl-watch(){
	entity="$1"
	if [[ -z "$entity" ]]; then
		echo "No entity given."
		return 1
	fi
	for ((i=1;i<=10000;i++)); 
	do 
	   sleep 1
	   clear && \
		echo "$entity" | tr '[:lower:]' '[:upper:]' | figlet && \
		kubectl get "$entity"
	done
}

mkcd() {
	if [ -d "$1" ]; then
		echo "$1 is already a directory"
		echo "Would you like to go to it? (yes/no)"
		read answer
		if [ "$answer" == 'yes' ] || [ "$answer" == 'y' ]; then
			cd "$1"
		fi
	else 
		echo "Making directory $1..."
		mkdir -p "$1"
		echo "Entering directory $1..."
		cd "$1"
	fi
}

moneyjohnandemily() {
	cd $GOG/GOHMoneyJAndE/
	# go build
	# exitStatus="$?"
	# if [[ $exitStatus -ne 0 ]]; then
	# 	echo "Unable build project"
	# 	return $exitStatus
	# fi
	./GOHMoneyJAndE
	exitStatus="$?"
	if [[ $exitStatus -ne 0 ]]; then
		echo "Error running GOHMoneyJAndE"
		return $exitStatus
	fi
}

moneybackups() {
	~/Dropbox/money/db/scripts/create-backups.sh
	exitStatus="$?"
	if [[ $exitStatus -ne 0 ]]; then
		echo "Unable to create-backups.sh. create-backups.sh error: $exitStatus"
		return $exitStatus
	fi
}

moneyjson() {
	cd $GOBB/GOHMoneyQuick/ && go build && ./GOHMoneyQuick
	exitStatus="$?"
	if [[ $exitStatus -ne 0 ]]; then
		echo "Unable to build money app and generate new json"
		return $exitStatus
	fi
}

moneygraph() {
	# cp $HOME/Dropbox/go/src/bitbucket.org/glynny/GOHMoneyQuick/out/money.json $MONEY/moneygraph/src/data/money.json
	cd $HOME/Dropbox/money/moneygraph/src && python -m SimpleHTTPServer 8000
}

mp3DownloadsToMusic() {
	if [ -f $DOWNLOADS/*.mp3 ]; then
		echo "MP3S WOOOOH"
		for mp3File in $DOWNLOADS/*.mp3; do
			mv "$mp3File" "$MUSIC"
			echo "Moving "$mp3File""
		done
		echo "Files moved to $MUSIC"
	else
		echo "No .mp3 files to move from $DOWNLOADS directory"
	fi
}

ssh-disk-capacity(){
	echo "ONLY DISKS BEGINNING WITH /dev"
	for server in "$@"; do
	echo "$server";
	ssh "$server" 'df -h' | grep --color=none -E '^/dev';
	done
}

stats(){
	echo "OS: ${OS}"
	echo "Shell: ${SHELL}"
}

tmux-dev() {
	sessionName="session-$(datestring)"
	tmux new-session -d -s "$sessionName"
	tmux split-window -h
	tmux split-window -v
	# -2 means force tmux to assume 256 colours
	tmux -2 attach-session -d 
}

toucho() {
	if [ -f "$1" ]; then
		echo "$1 already exists."
		read answer
		echo "Would you like to open it? (yes/no)"
		if [[ "$answer" =~ ^(yes|ye|y)$ ]]; then 
			open "$1"
		else
		    echo "$answer is not in the list"
		fi
	else
		touch "$1"
		open "$1"
	fi
}

unsetProxies() {
	unset http_proxy
	unset https_proxy
}

wifiedit(){
	if [[ ! -f "$WIFICODES" ]]; then
		echo "Cannot find wifi codes file at $WIFICODES"
		exit 1
	fi
	vim $WIFICODES
}

wifi() {
	name="$1"
	if [[ -z "$name" ]]; then
		cat $WIFICODES
		exit
	fi
	grep -i $name $WIFICODES 
}

augment-path-if-exists ~/scripts ~/bin
dotFilesDir="$(dirname $GOHBASHPROFILE)"
augment-path-if-exists $dotFilesDir/scripts
export-if-exists DOTFILESDIR $dotFilesDir

OS=$( uname | tr '[:upper:]' '[:lower:]')
osSpecificProfile="$dotFilesDir/$OS"
if [[ -f $osSpecificProfile ]]; then
	. $osSpecificProfile
else
	echo "No OS specific profile found at $osSpecificProfile"
fi

hn="$(hostname)"
hostnameSpecificProfile="$dotFilesDir/hostname/$hn"
if [[ -f $hostnameSpecificProfile ]]; then
	. $hostnameSpecificProfile
else
	echo "No hostname specific profile found at $hn"
fi

# Needs to be after loading GOPATH from specific hostname profile
if [[ -n "$GOPATH" ]]; then
	source-if-exists "$dotFilesDir/environment/go"
	augment-path-if-exists "$GOPATH/bin"
fi
